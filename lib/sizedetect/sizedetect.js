// Generated by CoffeeScript 1.3.1
(function() {
  var Capkom, Stat, StopWatch, _ref;

  Capkom = (_ref = this.Capkom) != null ? _ref : this.Capkom = {};

  jQuery.widget("Capkom.sizedetect", {
    options: {
      profile: Capkom.profile,
      maxSize: 200,
      minSize: 100,
      result: function(size, details) {
        var res, result;
        res = "<h2>Results</h2>";
        res += "Measured Sizes (these sizes depend from the screen size)";
        res += "<ul>";
        for (size in details) {
          result = details[size];
          res += "<li>\n  size: " + size + "px, score: " + (Math.round(result.score * 100)) + " %<br/>\n  Reaction time: average: " + result.reactionTimeAverage + ", standard deviation: " + result.reactionTimeStDev + "<br/>\n  Move time: average: " + result.moveTimeAverage + ", standard deviation: " + result.moveTimeStDev + "\n </li>";
        }
        res += "</ul>";
        res += "<p>Minimum size resulted in " + size + "</p>";
        jQuery('#results').html(res);
        return console.info('ideal size:', size, 'detailed results:', details);
      }
    },
    _create: function() {
      var _this = this;
      this.element.addClass('sizedetect-container');
      this.element.css({
        width: window.innerWidth - 30,
        height: window.innerHeight - 30
      });
      this.element.append("<div class='progressBar'></div>");
      this.progressBar = this.element.find(".progressBar");
      this.progressBar.css({
        'float': 'right',
        'width': '50%'
      });
      this.progressBar.progressbar();
      this.element.append("<button class='catchme'>Catch me!</button>");
      this.catchme = this.element.find('.catchme');
      console.info(this.catchme.button());
      this.catchme.click(function(e) {
        e.stopPropagation();
        return _this._attempt(true);
      });
      this.element.click(function(e) {
        return _this._attempt(false);
      });
      this.element.mousemove(function(e) {
        if (_this.notyetmoved) {
          _this.notyetmoved = false;
          _this.reactionTime = _this.reactionTimer.end();
          return _this.moveTimer.start();
        }
      });
      this.element.append('<div id="moveTime"></div>');
      this.element.append('<div id="reactionTime"></div>');
      this.details = {};
      this.moveTimer = new StopWatch;
      this.reactionTimer = new StopWatch;
      this.moveTimeStat = new Stat;
      this.reactionTimeStat = new Stat;
      return this._beginGame();
    },
    _destroy: function() {
      this.element.html("");
      this.element.removeClass('sizedetect-container');
      return this.element.css({
        width: 'auto',
        height: 'auto'
      });
    },
    _beginGame: function() {
      var level;
      level = 2;
      while (Math.floor((Math.min(window.innerWidth, window.innerHeight)) / level) > this.options.maxSize) {
        level++;
      }
      this._newLevel(level - 1);
      return this.notyetmoved = true;
    },
    _newLevel: function(level) {
      if (this.size < this.options.minSize) {
        return this.finish();
      } else {
        this.level = level;
        this.size = Math.floor((Math.min(window.innerWidth, window.innerHeight)) / this.level);
        this.currentLevel = this.details[this.size.toString()] = [];
        this.progressBar.progressbar('value', 0);
        this.catchme.css('width', this.size);
        this.catchme.css('height', this.size);
        this.moveTimeStat.clear();
        this.reactionTimeStat.clear();
        console.info('new level started with symbol size', this.size);
        return this._newPosition();
      }
    },
    _newPosition: function() {
      var maxLeft, maxTop;
      maxLeft = window.innerWidth - this.size - 30;
      maxTop = window.innerHeight - this.size - 30;
      this.catchme.css('left', Math.floor(Math.random() * maxLeft));
      this.catchme.css('top', Math.floor(Math.random() * maxTop));
      this.notyetmoved = true;
      return this.reactionTimer.clearAndStart();
    },
    _attempt: function(succeeded) {
      var moveTime, progress;
      if (succeeded) {
        moveTime = this.moveTimer.end();
        this.start = new Date().getTime();
        console.info('success', this.level, 'reactionTime:', this.reactionTime, 'moveTime:', moveTime);
        this.currentLevel.push({
          value: 1,
          moveTime: moveTime,
          reactionTime: this.reactionTime
        });
        this.reactionTimeStat.add(this.reactionTime);
        this.moveTimeStat.add(moveTime);
      } else {
        console.info('fail');
        this.currentLevel.push(0);
      }
      if (this.currentLevel.length >= 7) {
        this.evaluateCurrentLevel();
        if (this.currentLevel.score >= 0.5) {
          this.goodSize = this.size;
          if (this.currentLevel.moveTimeAverage < 2000) {
            return this._newLevel(this.level + 2);
          } else {
            return this._newLevel(this.level + 1);
          }
        } else {
          return this.finish();
        }
      } else {
        progress = (this.currentLevel.length / 7) * 100;
        console.info('progress:', progress);
        this.progressBar.progressbar('value', Math.floor(progress));
        if (succeeded) {
          this.reactionTimer.clear();
          this.moveTimer.clear();
          return this._newPosition();
        }
      }
    },
    finish: function() {
      if (this.goodSize) {
        this.options.result(this.goodSize, this.details);
      } else {
        alert("You cannot use the computer with your current devices. Consult with Platus.");
      }
      return this.destroy();
    },
    evaluateCurrentLevel: function() {
      var correct;
      correct = _.filter(this.currentLevel, function(r) {
        return r.value === 1;
      });
      this.currentLevel = this.details[this.size] = {
        score: correct.length / this.currentLevel.length,
        reactionTimeAverage: Math.round(this.reactionTimeStat.getAverage()),
        moveTimeAverage: Math.round(this.moveTimeStat.getAverage()),
        reactionTimeStDev: this.reactionTimeStat.getStandardDeviation(),
        moveTimeStDev: this.moveTimeStat.getStandardDeviation()
      };
      return console.info('level finished', this.level, this.currentLevel);
    }
  });

  Stat = (function() {

    Stat.name = 'Stat';

    function Stat(opts) {
      var options;
      options = {
        dropMargins: true
      };
      this.options = _.extend(options, opts);
      this._values = [];
    }

    Stat.prototype.getSamples = function() {
      var res;
      if (this.options.dropMargins) {
        res = _.sortBy(this._values, function(v) {
          return v;
        });
        return res.slice(1, -1);
      } else {
        return this._values;
      }
    };

    Stat.prototype.add = function(val) {
      return this._values.push(val);
    };

    Stat.prototype.length = function() {
      return this._values.length;
    };

    Stat.prototype.clear = function() {
      return this._values = [];
    };

    Stat.prototype.getAverage = function() {
      var smpls, sum;
      sum = 0;
      smpls = this.getSamples();
      _.each(smpls, function(val) {
        return sum += val;
      });
      return sum / smpls.length;
    };

    Stat.prototype.getVariance = function() {
      var av, smpls, v;
      av = this.getAverage();
      smpls = this.getSamples();
      v = 0;
      _.each(smpls, function(val) {
        return v += (av - val) * (av - val);
      });
      return v = v / smpls.length;
    };

    Stat.prototype.getStandardDeviation = function() {
      return Math.sqrt(this.getVariance());
    };

    return Stat;

  })();

  StopWatch = (function() {

    StopWatch.name = 'StopWatch';

    function StopWatch(error) {
      this.error = error != null ? error : function() {
        return console.error.apply(console, arguments);
      };
      this.elapsed = 0;
      this.status = 'idle';
    }

    StopWatch.prototype.start = function() {
      if (this.status === 'idle') {
        this.startTime = new Date().getTime();
        return this.status = 'running';
      } else {
        return this.error("Already running!");
      }
    };

    StopWatch.prototype.stop = function() {
      if (this.status === 'running') {
        this.elapsed += new Date().getTime() - this.startTime;
        return this.status = 'idle';
      } else {
        return this.error("Stop watch is not running, cannot stop!");
      }
    };

    StopWatch.prototype.clear = function() {
      this.elapsed = 0;
      return this.status = 'idle';
    };

    StopWatch.prototype.isRunning = function() {
      return this.status === 'running';
    };

    StopWatch.prototype.end = function() {
      var res;
      this.stop();
      res = this.elapsed;
      this.clear();
      return res;
    };

    StopWatch.prototype.clearAndStart = function() {
      this.clear();
      return this.start();
    };

    return StopWatch;

  })();

}).call(this);
